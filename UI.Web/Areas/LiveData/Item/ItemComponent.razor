@using System.Diagnostics;
@using Core.Validation;
@using Framework.Services;
@using Microsoft.AspNetCore.SignalR.Client;
@using Framework.Extensions;
@using UI.Web.Areas.LiveData.List
@using UI.Web.Data.Common
@using UI.Web.Services;

@inject ReminderService ReminderService
@inject ItemStyleService ItemStyleService;
@inject ItemDragDropService ItemDragDropService;
@inject ItemHandlerService ItemHandlerService;

<tr id=@Model.Id @ref=@ItemReference class="bg-opacity-25 align-items-baseline @(Level == 0 ? "top" : string.Empty) @(Model.Done.HasValue ? "bg-success" : string.Empty) @(Hidden ? "text-secondary text-opacity-25" : null)"
    draggable="true" @ondragstart=@(_ => ItemDragDropService.HandleDragStart(Container, Model)) ondragover="event.preventDefault();" @ondrop=@(_ => ItemDragDropService.HandleDrop(Container, Model, OnDraggedFrom, OnDraggedTo, StateHasChanged))
    @attributes=@ItemStyleService.GetRowAttributes(Model, Hidden, false)>
    <td class="fixed-w position-relative fade-in-on-hover">
        <div class="moveChild up text-center text-white p-0 position-absolute" @onclick=@(_ => OnOrderChanged.InvokeAsync((Model, -1)))>
            <span class="fa fa-caret-up" aria-hidden="true"></span>
        </div>

        <div class="moveChild down text-center text-white p-0 position-absolute" @onclick=@(_ => OnOrderChanged.InvokeAsync((Model, 1)))>
            <span class="fa fa-caret-down" aria-hidden="true"></span>
        </div>

        <span class="fa fa-grip-vertical opacity-25"></span>
    </td>

    <td class="fixed-w position-relative">
        @if(Model.Order != default)
        {
            <div class="removeOrder text-center text-white p-0 position-absolute" @onclick=@(_ => OnOrderRemoved.InvokeAsync(Model))>
                <span class="fa fa-xmark" aria-hidden="true"></span>
            </div>
        }

        <div class="addChild text-center text-white p-0 position-absolute" @onclick=@(() => newItemModel = ToDoItemDomainModel.Create(Model.Id, Model.CategoryId, ListId))>
            <span class="fa fa-plus" aria-hidden="true"></span>
        </div>

        <div class="px-2 @((Model.Done.HasValue || Hidden || Model.InactiveSince.HasValue) ? "" : "markToDoDone fade-in-on-hover") p-0">
            @if (Model.Done.HasValue)
            {
                <span class="text-success" @onclick=@DoneChanged><i class="fa fa-check" aria-hidden="true"></i></span>
            }
            else
            {
                <span class="opacity-25" @onclick=@DoneChanged><i class="fa fa-check" aria-hidden="true"></i></span>
            }
        </div>
    </td>

    <td class="position-relative" @attributes=@ItemStyleService.GetPaddingLeft(Level) @onclick=@BezeichnungEditEnabledChanged>
        @if (!BezeichnungEditEnabled)
        {
            @BezeichnungFragment
            if(!string.IsNullOrWhiteSpace(OccurrenceString))
            {
                <span class="next-occurrence-info">@OccurrenceString</span>
            }
        }
        else
        {
            <EditForm Model=@Model>
                <DataAnnotationsValidator />

                <input type="text" @bind-value=@Model.Bezeichnung id="bezeichnung" class="form-control" @onkeyup=@(async (KeyboardEventArgs key) => { if(key.Code == "Enter") await BezeichnungChanged(context); }) @onblur=@(() => BezeichnungChanged(context)) />
                <ValidationMessage For=@(() => Model.Bezeichnung) />
            </EditForm>
        }
    </td>

    <td class="fixed-w text-end fade-in-on-hover">
        @if(!string.IsNullOrWhiteSpace(OccurrenceString))
        {
            <span class="px-2 position-relative fa fa-clock @(Model.NextOrLastOccurrence < DateTime.Now ? "opacity-50" : string.Empty)" tooltip=@OccurrenceString @onclick=@(() => NavigationManager.NavigateTo(NavigationManager.BaseUri + $"schedule/{Model.Id}"))></span>
        }
        else
        {
            <span class="px-2 position-relative fa-regular fa-clock opacity-25" @onclick=@(() => NavigationManager.NavigateTo(NavigationManager.BaseUri + $"schedule/{Model.Id}"))></span>
        }
    </td>

    <td class="fixed-w fw-normal">
        <IconSelect OnlyShowIcon=true Selected=@Model.Category?.Bezeichnung BackgroundColor=@UIColorService.GetSimpleBackgroundColor(Model.Category?.RGB_A) SelectedChanged=@CategoryChanged ElementsWithIcons=@Categories.Select(c => (Icon: c.Icon, Element: c.Bezeichnung))></IconSelect>
    </td>

    <td class="fixed-w fade-in-on-hover">
        @if (!Hidden)
        {
            <span class="px-2 fa fa-xmark opacity-25" aria-hidden="true" @onclick=@(() => ActiveChanged())></span>
        }
        else
        {
            <span class="opacity-25">&emsp;</span>
        }
    </td>
</tr>

@if (!Model.InactiveSince.HasValue && !Hidden)
{
    @if (newItemModel != null)
    {
        <tr>
            <td colspan="5">
                <ItemNewComponent Model=newItemModel Level=@(Level + 1) OnChange=@(async item => Model.Children = await ItemHandlerService.HandleNewChange(Model.Children, item, UpdateNotifyAction))></ItemNewComponent>
            </td>
        </tr>
    }
}

@if (Model.Children?.Any() == true)
{
    foreach (var child in Model.Children.OrderBy(item => item.Done.HasValue).ThenBy(item => item.Order).ThenByDescending(item => item.NextOrLastOccurrence))
    {
        if (InactiveMode && !child.VisuallyDeactivated && !child.InactiveSince.HasValue)
            continue;

        <ItemComponent Model=child Level=@(Level + 1) InactiveMode=InactiveMode ListId=ListId TopLevel=@TopLevel
            OnBezeichnungEditEnabled=@(original => OnBezeichnungEditEnabled.InvokeAsync(original))
            OnRemove=@(async item => await ItemHandlerService.HandleRemove(Model.Children, item, OnRemove, StateHasChanged))
            OnDraggedFrom=@(info => ItemDragDropService.HandleDraggedFrom(info.Source, info.Item, OnDraggedFrom, StateHasChanged))
            OnDraggedTo=@(info => ItemDragDropService.HandleDraggedTo(info.Destination, info.Item, OnDraggedTo, StateHasChanged))
            OnDoneChanged=@StateHasChanged
            OnOrderChanged=@(async (ci) => await ItemHandlerService.ChangeChildOrder(Model.Children, ci.Item, ci.Movement, StateHasChanged))
            OnOrderRemoved=@(async (item) => await ItemHandlerService.RemoveOrder(Model.Children, item, StateHasChanged))></ItemComponent>
    }
}

@if(Level == 0)
{
    <tr class="todo-item-separator" ondragover="event.preventDefault();" @ondrop=@(_ => ItemDragDropService.HandleDrop(Container, null, OnDraggedFrom, OnDraggedTo, StateHasChanged)) @attributes=@ItemStyleService.GetRowAttributes(Model, Hidden, true)>
        <td colspan="6" class="border-bottom-0"></td>
    </tr>
}

@code {
    [CascadingParameter]
    ListComponent Container { get; set; } = new ListComponent();

    [CascadingParameter]
    public Modal? PageModal { get; set; }

    [CascadingParameter]
    public IdentityUser? User { get; set; }

    [CascadingParameter]
    public HubConnection? ListHubConnection { get; set; }

    [CascadingParameter]
    public List<CategoryDomainModel> Categories { get; set; } = new List<CategoryDomainModel>();

    [Parameter]
    public List<ToDoItemDomainModel> TopLevel { get; set; } = new List<ToDoItemDomainModel>();

    [Parameter]
    public ToDoItemDomainModel Model { get; set; } = new ToDoItemDomainModel();

    [Parameter]
    public bool InactiveMode { get; set; } = false;

    [Parameter]
    public int Level { get; set; }

    [Parameter]
    public Guid ListId { get; set; }

    [Parameter]
    public EventCallback<ToDoItemDomainModel> OnRemove { get; set; }

    [Parameter]
    public EventCallback<(ToDoItemDomainModel? Destination, ToDoItemDomainModel Item)> OnDraggedTo { get; set; }

    [Parameter]
    public EventCallback<(ToDoItemDomainModel? Source, ToDoItemDomainModel Item)> OnDraggedFrom { get; set; }

    [Parameter]
    public EventCallback OnDoneChanged { get; set; }

    private ElementReference reference;
    public ElementReference ItemReference { get => reference; private set { reference = value; OnReferenced.InvokeAsync(value); } }

    [Parameter]
    public EventCallback<ElementReference> OnReferenced { get; set; }

    [Parameter]
    public EventCallback<(ToDoItemDomainModel Item, int Movement)> OnOrderChanged { get; set; }

    [Parameter]
    public EventCallback<ToDoItemDomainModel> OnOrderRemoved { get; set; }

    [Parameter]
    public EventCallback<ItemComponent> OnBezeichnungEditEnabled { get; set; }

    private ToDoItemDomainModel? newItemModel { get; set; } = null;

    private bool bezeichnungEditEnabled = false;
    public bool BezeichnungEditEnabled { get => bezeichnungEditEnabled; set { bezeichnungEditEnabled = value; StateHasChanged(); } }
    private DateTime? date { get; set; }
    private DateTime? timeOfDay { get; set; }
    private bool Hidden => InactiveMode && !Model.InactiveSince.HasValue;
    private RenderFragment BezeichnungFragment => (__builder) => __builder.AddMarkupContent(0, ItemContentRenderService.RenderContent(Model.Bezeichnung));
    private List<(string Icon, string Element)> CategorySelect { get; set; } = new List<(string Icon, string Element)>();
    private string OccurrenceString
    {
        get
        {
            if (Model.NextOrLastOccurrence == null)
                return string.Empty;

            var result = Model.NextOrLastOccurrence.Value.ToShortDateString();
            if (Model.NextOrLastOccurrence.Value.TimeOfDay.TotalSeconds > 0)
                result += $" - {Model.NextOrLastOccurrence.Value.ToShortTimeString()}";

            return result;
        }
    }

    private Action UpdateNotifyAction => async () =>
    {
        newItemModel = null;
        StateHasChanged();
        if (User != default && ListHubConnection!.State == HubConnectionState.Connected)
            await ListHubConnection!.SendAsync("BroadcastListChanged", ListId, User);
    };


    protected override void OnInitialized()
    {
        try
        {
            date = Model.NextOrLastOccurrence?.Date;
            timeOfDay = Model.NextOrLastOccurrence;
        }
        catch (Exception ex)
        {
            LoggerFactory.CreateLogger(GetType()).LogError(ex, ex.Message);
        }
    }

    protected override void OnParametersSet()
    {
        try
        {
            Model.Children.ForEach((dm, i) => dm.Set("OriginalOrder", i));
            CategorySelect = Categories.Select(c => (Icon: c.Icon, Element: c.Bezeichnung)).ToList();
        }
        catch (Exception ex)
        {
            LoggerFactory.CreateLogger(GetType()).LogError(ex, ex.Message);
        }

        base.OnParametersSet();
    }

    private async Task BezeichnungEditEnabledChanged()
    {
        try
        {
            var wasActive = BezeichnungEditEnabled;
            BezeichnungEditEnabled = !Model.InactiveSince.HasValue && !Hidden;
            if (!wasActive)
                await OnBezeichnungEditEnabled.InvokeAsync(this);
        }
        catch (Exception ex)
        {
            LoggerFactory.CreateLogger(GetType()).LogError(ex, ex.Message);
        }
    }

    private async Task DoneChanged()
    {
        try
        {
            if (Hidden || Model.InactiveSince.HasValue)
                return;

            if (Model.Done == null)
                Model.Done = DateTime.Now;
            else
                Model.Done = null;

            await ItemRepository.UpdateAndSaveAsync(ModelMapper.Map(Model));
            EventHandlerService.RaiseEvent("ListChanged", new ListChangedEventArgs(ListChangeType.Update, Model));
            await OnDoneChanged.InvokeAsync(Model);

            if (User != default && ListHubConnection!.State == HubConnectionState.Connected)
                await ListHubConnection.SendAsync("BroadcastListChanged", ListId, User);
        }
        catch (Exception ex)
        {
            LoggerFactory.CreateLogger(GetType()).LogError(ex, ex.Message);
        }
    }

    private async Task BezeichnungChanged(EditContext context)
    {
        try
        {
            var valid = context.Validate();
            if (valid)
            {
                await ItemRepository.UpdateAndSaveAsync(ModelMapper.Map(Model));
                EventHandlerService.RaiseEvent("ListChanged", new ListChangedEventArgs(ListChangeType.Update, Model));
                BezeichnungEditEnabled = false;
                await OnBezeichnungEditEnabled.InvokeAsync(null);

                await ReminderService.UpdateReminders(Model.Id);

                if (User != default && ListHubConnection!.State == HubConnectionState.Connected)
                    await ListHubConnection.SendAsync("BroadcastListChanged", ListId, User);
            }
        }
        catch (Exception ex)
        {
            LoggerFactory.CreateLogger(GetType()).LogError(ex, ex.Message);
        }
    }

    private async Task ActiveChanged(bool validated = false)
    {
        try
        {
            if (Hidden)
                return;

            if (Model.Children?.Any() == true && !validated)
            {
                PageModal.NotNull();

                PageModal!.Title = @<h5>Achtung!</h5>;
                PageModal.Body =@<div class="row align-items-center">
                    <div class="col-3 text-center">
                        <span class="fa fa-warning text-warning fs-2" aria-hidden="true"></span>
                    </div>

                    <div class="col-9 text-start">Das Item "@(Model.Bezeichnung)" besitzt Unter-Items. Möchten Sie alle Items @(Model.InactiveSince.HasValue ? "inaktiv" : "aktiv") setzen?</div>
                </div>
                ;

                PageModal.AcceptActionAsync = async () => await ActiveChanged(true);

                PageModal.Show();
                return;
            }
            else if (validated == true)
                SetActiveStateForAll(Model, Model.InactiveSince.HasValue ? null : DateTime.Now);
            else
                Model.InactiveSince = Model.InactiveSince.HasValue ? null : DateTime.Now;

            await ItemRepository.UpdateAndSaveAsync(ModelMapper.MapToArray(Model.SelfAndAllDescendents));
            EventHandlerService.RaiseEvent("ListChanged", new ListChangedEventArgs(ListChangeType.Delete, Model));
            StateHasChanged();

            await ReminderService.UpdateReminders(Model.Id);
            await OnRemove.InvokeAsync(Model);

            if (User != default && ListHubConnection!.State == HubConnectionState.Connected)
                await ListHubConnection.SendAsync("BroadcastListChanged", ListId, User);
        }
        catch (Exception ex)
        {
            LoggerFactory.CreateLogger(GetType()).LogError(ex, ex.Message);
        }
    }

    private async Task CategoryChanged(string categoryValue)
    {
        try
        {
            var selectedCategory = Categories.FirstOrDefault(c => c.Bezeichnung == categoryValue);
            Model.CategoryId = selectedCategory?.Id;
            Model.Category = selectedCategory;

            await ItemRepository.UpdateAndSaveAsync(ModelMapper.Map(Model));
            EventHandlerService.RaiseEvent("ListChanged", new ListChangedEventArgs(ListChangeType.Update, Model));
            StateHasChanged();

            if (User != default && ListHubConnection!.State == HubConnectionState.Connected)
                await ListHubConnection.SendAsync("BroadcastListChanged", ListId, User);
        }
        catch (Exception ex)
        {
            LoggerFactory.CreateLogger(GetType()).LogError(ex, ex.Message);
        }
    }

    private void SetActiveStateForAll(ToDoItemDomainModel item, DateTime? activeValue)
    {
        foreach (var childItem in item.Children)
            SetActiveStateForAll(childItem, activeValue);

        item.InactiveSince = activeValue;
    }
}