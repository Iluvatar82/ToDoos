@page "/list/{ListId:guid}"
@using System.Security.Claims;
@using Core.Common;
@using Framework.Converter;
@using Core.Validation;
@using Framework.Services;
@using Framework.Extensions;
@using Microsoft.AspNetCore.SignalR.Client;
@using UI.Web.Hubs;

@inject ToastNotificationService ToastService
@inject EmailService EmailService;
@inject IJSRuntime JS

<AuthorizeView>
    <NotAuthorized>
        <h4>Bitte einloggen!</h4>
        <div>
            <a href=@(NavigationManager.BaseUri + "Identity/Account/Login")>Login Page</a>
        </div>
    </NotAuthorized>

    <Authorized>
        <h4>@listInformation?.Name
            <span @onclick=@(() =>NavigationManager.NavigateTo(NavigationManager.BaseUri + $"list/edit/{ListId}"))><i class="fa-solid fa-gears small ms-2"></i></span>
        </h4>

        <div class="d-flex mb-3">
            <div class="col p-3 border border-1 bg-light">
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" role="switch" id="showInactiveControl"  @onchange=@SwitchActiveInactiveView>
                    <label class="form-check-label" for="showInactiveControl">Zeige bereits gelöschte/entfernte ToDo's</label>
                </div>
            </div>
        </div>

        <div class="row mb-3">
            <div class="btn-group col-3" role="group">
                <button type="button" @onclick="NavigateBack" class="btn btn-outline-secondary">Zurück</button>
                <button @onclick=@(() => newSubModel = ToDoItemDomainModel.Create(null, null, ListId)) class="btn btn-outline-primary" disabled=@showInactive>Hinzufügen</button>
            </div>
        </div>

        @if (newSubModel != null)
        {
            <div class="row mt-2">
                <ToDoNew Model=newSubModel OnChange=@HandleNewChange></ToDoNew>
            </div>
        }

        <CascadingValue Value=@this>
            @if (myToDos.Any() && !showTwoColumns)
            {
                <div class="table-responsive">
                    <table class="table">
                        <tbody>
                            @foreach (var item in myToDos)
                            {
                                var index = myToDos.IndexOf(item);
                                <ToDoItem_Component Model=item Level=0 InactiveMode=@showInactive ListId=ListId
                                    OnBezeichnungEditEnabled=@HandleBezeichnungEnabled
                                    OnRemove=@HandleRemove OnDraggedFrom=@(info => HandleDraggedFrom(info.Source, info.Item)) OnDraggedTo=@(info => HandleDraggedTo(info.Destination, info.Item))
                                    OnDoneChanged=@StateHasChanged OnReferenced=@(reference => topLevelReferenceList.Add(reference))
                                    OnOrderChanged=@((ci) => ChangeChildOrder(ci.Item, ci.Movement)) OnOrderRemoved=@RemoveOrder></ToDoItem_Component>
                            }
                        </tbody>
                    </table>
                </div>
            }
            else if (myToDos.Any())
            {
                <div class="row" data-masonry='{ "percentPosition": true }'>
                    @foreach (var item in myToDos)
                    {
                        var index = myToDos.IndexOf(item);
                        <div class="col-sm-6">
                            <div class="card">
                                <div class="p-1">
                                    <table class="table mb-0">
                                        <tbody>
                                            <ToDoItem_Component Model=item Level=0 InactiveMode=@showInactive ListId=ListId 
                                                OnBezeichnungEditEnabled=@HandleBezeichnungEnabled
                                                OnRemove=@HandleRemove OnDraggedFrom=@(info => HandleDraggedFrom(info.Source, info.Item)) OnDraggedTo=@(info => HandleDraggedTo(info.Destination, info.Item))
                                                                OnDoneChanged=@StateHasChanged OnReferenced=@(reference => topLevelReferenceList.Add(reference))
                                                OnOrderChanged=@((ci) => ChangeChildOrder(ci.Item, ci.Movement)) OnOrderRemoved=@RemoveOrder></ToDoItem_Component>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    }
                </div>
                <script src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha384-GNFwBvfVxBkLMJpYMOABq3c+d3KnQxudP/mGPkzpZSTYykLBNsZEnG2D9G/X/+7D" crossorigin="anonymous" async></script>
            }
        </CascadingValue>
    </Authorized>
</AuthorizeView>

<script>
    window.topLevelSelector = 'table tbody tr.top';
    window.currentElement = null;
    window.currentIndex = 0;
    window.allowKeyboardNavigation = true;

    document.onkeypress = function (e) {
        if (e.key == "j" && allowKeyboardNavigation) {
            let topLevelElements = document.querySelectorAll(window.topLevelSelector);
            currentIndex++;
            if (currentIndex >= topLevelElements.length)
                currentIndex = 0;

            if (currentElement != null)
                currentElement.classList.remove('active');

            currentElement = topLevelElements[currentIndex];
            currentElement.classList.add('active');

            window.scrollTo({
                    behavior: 'smooth',
                    top:
                        currentElement.getBoundingClientRect().top -
                        document.body.getBoundingClientRect().top -
                        document.querySelectorAll('.top-row')[0].getBoundingClientRect().height,
                });
        }
        else if (e.key == "k" && allowKeyboardNavigation) {
            let topLevelElements = document.querySelectorAll(window.topLevelSelector);
            currentIndex--;
            if (currentIndex < 0)
                currentIndex = topLevelElements.length - 1;

            if (currentElement != null)
                currentElement.classList.remove('active');

            currentElement = topLevelElements[currentIndex];
            currentElement.classList.add('active');

            window.scrollTo({
                behavior: 'smooth',
                top:
                    currentElement.getBoundingClientRect().top -
                    document.body.getBoundingClientRect().top -
                    document.querySelectorAll('.top-row')[0].getBoundingClientRect().height,
            });
        }
    };


    allowKeyNavigation = function (value) {
        debugger;
        allowKeyboardNavigation = value;
        if (value == false && currentElement != null) { 
            currentElement.classList.remove('active');
            currentElement = null;
        }
    };
</script>

@code {
    private ToDoItemDomainModel? newSubModel = null;
    private List<ToDoItemDomainModel> myToDos = new List<ToDoItemDomainModel>();
    private bool showInactive { get; set; }
    private global::ToDo.Data.ToDoData.Entities.ToDoList? listInformation { get; set; }
    private bool showTwoColumns { get; set; } = false;

    private List<ElementReference> topLevelReferenceList { get; set; } = new List<ElementReference>();
    private ElementReference currentTopLevelReference { get; set; }

    public ToDoItemDomainModel? DraggedToDoItem { get; set; }

    [Parameter]
    public Guid ListId { get; set; }
    private Guid previousListId { get; set; }

    [CascadingParameter]
    public IdentityUser? User { get; set; }

    [CascadingParameter]
    public HubConnection? ListHubConnection { get; set; }

    protected override async Task OnInitializedAsync()
    {
        ListHubConnection?.On<string>("JoinedList", async (username) =>
        {
            await ToastService.SendAsync("Beigetreten", $"{username} hat die Liste geöffnet!", Framework.Services.Base.MessageType.Info);
            await InvokeAsync(StateHasChanged);
        });

        ListHubConnection?.On<string>("UpdateList", async (username) =>
        {
            await ToastService.SendAsync("Aktualisiert", $"{username} hat die Liste aktualisiert!.{Environment.NewLine}Lade Änderungen...", Framework.Services.Base.MessageType.Info);
            await InvokeAsync(async () =>
            {
                await RetrieveItems();
                StateHasChanged();
            });
        });

        ListHubConnection?.On<string>("LeftList", async (username) =>
        {
            await ToastService.SendAsync("Verlassen", $"{username} hat die Liste geschlossen!", Framework.Services.Base.MessageType.Info);
            await InvokeAsync(StateHasChanged);
        });

        if (ListId == default)
        {
            var _currentUser = (await AuthenticationProvider.GetAuthenticationStateAsync()).User;
            if (_currentUser?.Claims.Any() != true)
                return;

            ListId = Guid.Parse(_currentUser.Claims!.First(c => c.Type.Contains("nameidentifier")).Value);
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (previousListId == ListId)
            return;

        if (User != default)
        {
            var twoColumnSetting = await SettingRepository.GetSettingAsync(Guid.Parse(User.Id), Settings.TwoColumns);
            if (twoColumnSetting != null)
                showTwoColumns = twoColumnSetting.Value.GetBool();
        }

        await RetrieveItems();
        await base.OnParametersSetAsync();

        listInformation = await UserRepository.GetListAsync(ListId);
        if (!listInformation.IsUserList && ListHubConnection != null && User != default)
            await ListHubConnection.SendAsync("JoinedGroupList", ListId, User);

        await ToastService.SendAsync("Liste geöffnet", $"Liste <b>{listInformation.Name}</b> wurde geöffnet!", Framework.Services.Base.MessageType.Info);

        previousListId = ListId;
    }

    private async Task SwitchActiveInactiveView()
    {
        showInactive = !showInactive;

        await RetrieveItems();

        StateHasChanged();
    }

    private async Task RetrieveItems()
    {
        if (ListId == default)
        {
            myToDos = new List<ToDoItemDomainModel>();
            return;
        }

        if (!showInactive)
        {
            myToDos = Mapper.Map<List<ToDoItemDomainModel>>(await ItemRepository.GetAllItemsCompleteAsync(ListId, !showInactive))
                .OrderBy(item => item.Done.HasValue)
                .ThenBy(item => item.Order)
                .ThenByDescending(item => item.NextOrLastOccurrence)
                .ForEach((dm, index) => dm.Set("OriginalOrder", index))
                    .Where(item => item.Parent == null)
                    .ToList();
        }
        else
        {
            var allItems = Mapper.Map<List<ToDoItemDomainModel>>(await ItemRepository.GetAllItemsCompleteAsync(ListId));
            myToDos = BuildInactiveItemsFromAll(allItems)
                .OrderBy(item => item.Done.HasValue)
                .ThenBy(item => item.Order)
                .ThenByDescending(item => item.NextOrLastOccurrence)
                .ForEach((dm, index) => dm.Set("OriginalOrder", index))
                    .ToList();
        }

        topLevelReferenceList = new List<ElementReference>();
    }

    private List<ToDoItemDomainModel> BuildInactiveItemsFromAll(List<ToDoItemDomainModel> allItems)
    {
        var allInactiveItems = allItems.Where(item => !item.IsActive);
        var result = new HashSet<ToDoItemDomainModel>();

        foreach (var inactiveItem in allInactiveItems)
        {
            var currentItem = inactiveItem;
            while(currentItem.Parent != null)
            {
                currentItem = currentItem.Parent;
                if (currentItem.VisuallyDeactivated == true)
                    break;

                if (currentItem.IsActive)
                    currentItem.VisuallyDeactivated = true;
            }

            if (!result.Contains(currentItem))
                result.Add(currentItem);
        }

        return result.ToList();
    }

    private async Task HandleNewChange(ToDoItemDomainModel? item)
    {
        newSubModel = null;
        if (item != null)
        {
            myToDos.Add(item);
            myToDos = myToDos
                .OrderBy(item => item.Done.HasValue)
                .ThenBy(item => item.Order)
                .ThenByDescending(item => item.NextOrLastOccurrence)
                .ForEach((dm, index) => dm.Set("OriginalOrder", index))
                   .Where(item => item.Parent == null)
                   .ToList();
        }

        StateHasChanged();

        if (User != default)
            await ListHubConnection!.SendAsync("BroadcastListChanged", ListId, User);
    }

    private void NavigateBack()
    {
        NavigationManager.NavigateTo(NavigationManager.BaseUri);
    }

    private async Task HandleRemove(ToDoItemDomainModel todoItem)
    {
        myToDos.Remove(todoItem);
        StateHasChanged();

        if (User != default)
            await ListHubConnection!.SendAsync("BroadcastListChanged", ListId, User);
    }

    private async Task HandleDraggedFrom(ToDoItemDomainModel source, ToDoItemDomainModel item)
    {
        if (source != null)
            return;

        myToDos.Remove(item);

        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleDraggedTo(ToDoItemDomainModel destination, ToDoItemDomainModel item)
    {
        if (destination != null)
            return;

        if (!myToDos.Contains(item))
        {
            myToDos.Add(item);
            myToDos = myToDos
                .OrderBy(item => item.Done.HasValue)
                .ThenBy(item => item.Order)
                .ThenByDescending(item => item.NextOrLastOccurrence)
                .ForEach((dm, index) => dm.Set("OriginalOrder", index))
                   .Where(item => item.Parent == null)
                   .ToList();
        }

        await InvokeAsync(StateHasChanged);
    }

    private ToDoItem_Component? currentEditItemComponent = null;
    private async Task HandleBezeichnungEnabled(ToDoItem_Component? component)
    {
        if (currentEditItemComponent != null)
            currentEditItemComponent.BezeichnungEditEnabled = false;

        currentEditItemComponent = component;
        await JS.InvokeVoidAsync("allowKeyNavigation", component == null);
    }

    private async Task ChangeChildOrder(ToDoItemDomainModel itemToMove, int change)
    {
        if (!myToDos.Contains(itemToMove))
            return;

        var currentIndex = myToDos.IndexOf(itemToMove);
        myToDos.Remove(itemToMove);
        var newIndex = Math.Clamp(currentIndex + change, 0, myToDos.Count);
        myToDos.Insert(newIndex, itemToMove);

        for (var index = 0; index < myToDos.Count; index++)
            myToDos[index].Order = index;

        await ItemRepository.UpdateAndSaveAsync(Mapper.Map<ToDoItem[]>(myToDos));

        await InvokeAsync(StateHasChanged);
    }

    private async Task RemoveOrder(ToDoItemDomainModel item)
    {
        if (!myToDos.Contains(item))
            return;

        for (var index = 0; index < myToDos.Count; index++)
            myToDos[index].Order = 0;

        myToDos = myToDos.OrderBy(i => i.Get<int>("OriginalOrder")).ToList();

        await ItemRepository.UpdateAndSaveAsync(Mapper.Map<ToDoItem[]>(myToDos));

        await InvokeAsync(StateHasChanged);
    }
}
